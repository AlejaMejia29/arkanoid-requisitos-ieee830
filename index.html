<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Especificaci√≥n de Requisitos - Arkanoid Revolution</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="CSS/style.css">
</head>

<body>
    <header class="main-header">
        <div class="container">
            <h1 class="mb-1">Especificaci√≥n de Requisitos del Software (ERS)</h1>
            <h2 class="h5">Videojuego Arkanoid Revolution - Basado en IEEE 830</h2>
        </div>
    </header>

    <main class="container my-5">
        <section class="mb-4">
            <h2>Resumen del Videojuego</h2>
            <p>
                "Arkanoid Revolution" es un videojuego arcade que retoma la esencia del cl√°sico Arkanoid, mejor√°ndola
                con una experiencia gr√°fica moderna, niveles con mayor dinamismo, mec√°nicas variadas y una curva de
                dificultad progresiva. El jugador asume el control de una plataforma ubicada en la parte inferior de la
                pantalla, cuya misi√≥n es evitar que una pelota caiga, devolvi√©ndola con precisi√≥n para destruir una
                serie de bloques que se ubican en la parte superior.
            </p>
            <p>
                A medida que avanza, el jugador desbloquear√° bonificaciones (como multiplicadores, rayos l√°ser, pelotas
                m√∫ltiples, entre otros) y se enfrentar√° a nuevos retos como bloques m√≥viles, enemigos que interfieren el
                rebote, y niveles con gravedades modificadas.
            </p>
            <p>
                El juego se divide en distintos niveles con objetivos y condiciones espec√≠ficas: desde eliminar todos
                los bloques en un tiempo l√≠mite, hasta proteger ciertas estructuras o alcanzar una puntuaci√≥n m√≠nima
                para avanzar. La interfaz es minimalista y amigable, y el sistema de retroalimentaci√≥n (sonido,
                vibraci√≥n, animaciones) est√° dise√±ado para mantener al jugador inmerso. Con soporte para dispositivos
                t√°ctiles y de escritorio, "Arkanoid Revolution" busca ser un t√≠tulo accesible para todo tipo de jugador,
                promoviendo la rejugabilidad mediante tablas de puntajes, logros desbloqueables y contenido oculto que
                se desbloquea con el progreso.
            </p>
        </section>
        <section class="mb-4">
            <h2>√çndice</h2>
            <ul>
                <li><strong>1. Introducci√≥n</strong>
                    <ul>
                        <li>1.1. Prop√≥sito</li>
                        <li>1.2. √Åmbito del Sistema</li>
                        <li>1.3. Definiciones, Acr√≥nimos y Abreviaturas</li>
                        <li>1.4. Referencias</li>
                        <li>1.5. Visi√≥n General del Documento</li>
                    </ul>
                </li>
                <li><strong>2. Descripci√≥n General</strong>
                    <ul>
                        <li>2.1. Perspectiva del Producto</li>
                        <li>2.2. Funciones del Producto</li>
                        <li>2.3. Caracter√≠sticas de los Usuarios</li>
                        <li>2.4. Restricciones</li>
                        <li>2.5. Suposiciones y Dependencias</li>
                        <li>2.6. Requisitos Futuros</li>
                    </ul>
                </li>
                <li><strong>3. Requisitos Espec√≠ficos</strong>
                    <ul>
                        <li>3.1. Interfaces Externas</li>
                        <li>3.2. Funciones</li>
                        <li>3.3. Requisitos de Rendimiento</li>
                        <li>3.4. Restricciones de Dise√±o</li>
                        <li>3.5. Atributos del Sistema</li>
                        <li>3.6. Otros Requisitos</li>
                    </ul>
                </li>
            </ul>
        </section>
        <section class="mb-4">
            <h2>1. Introducci√≥n</h2>

            <h3>1.1. Prop√≥sito</h3>
            <p>
                El presente documento tiene como prop√≥sito especificar de manera detallada los requerimientos
                funcionales y no funcionales del videojuego "Arkanoid Revolution", bajo el est√°ndar IEEE 830. Est√°
                dirigido a desarrolladores, testers, dise√±adores y otros interesados en el proceso de desarrollo del
                software.
            </p>

            <h3>1.2. √Åmbito del Sistema</h3>
            <p>
                El sistema a desarrollar es un videojuego arcade tipo Arkanoid para navegadores y dispositivos m√≥viles.
                El juego permitir√° al jugador interactuar mediante teclado o pantalla t√°ctil, rebotar la pelota,
                destruir bloques, obtener mejoras, superar niveles y registrar puntajes. No incluir√° opciones
                multijugador ni integraci√≥n en la nube en esta versi√≥n.
            </p>

            <h3>1.3. Definiciones, Acr√≥nimos y Abreviaturas</h3>
            <ul>
                <li><strong>UI:</strong> Interfaz de Usuario</li>
                <li><strong>FPS:</strong> Frames por Segundo</li>
                <li><strong>HTML5:</strong> Lenguaje de marcado usado para crear la estructura del juego</li>
                <li><strong>API:</strong> Interfaz de Programaci√≥n de Aplicaciones</li>
                <li><strong>UX:</strong> Experiencia del Usuario</li>
            </ul>

            <h3>1.4. Referencias</h3>
            <ul>
                <li>IEEE Std 830-1998</li>
                <li>Documentaci√≥n de Phaser.js (motor de juegos)</li>
            </ul>

            <h3>1.5. Visi√≥n General del Documento</h3>
            <p>
                Este documento sigue la estructura del est√°ndar IEEE 830 y se divide en tres partes: descripci√≥n general
                del sistema, requerimientos espec√≠ficos (funcionales y no funcionales).
            </p>
        </section>
        <section class="mb-4">
            <h2>2. Descripci√≥n General</h2>

            <h3>2.1. Perspectiva del Producto</h3>
            <p>
                El producto es independiente y aut√≥nomo, instalable como aplicaci√≥n m√≥vil. No requiere conexi√≥n
                permanente a internet. Su arquitectura est√° basada en MVC, y se ejecuta sobre el sistema operativo
                Android/iOS.
                <br>Ejemplo: un usuario descarga Arkanoid en su celular, lo ejecuta, elige un nivel inicial y comienza a
                jugar sin requerir cuenta o conexi√≥n.

            </p>

            <h3>2.2. Funciones del Producto</h3>
            <ul>
                <li>Iniciar partida desde men√∫ principal</li>
                <li>Controlar la plataforma deslizando el dedo horizontalmente</li>
                <li>Detectar colisiones entre la pelota y los bloques</li>
                <li>Romper bloques y actualizar el puntaje</li>
                <li>Aumentar dificultad con cada nivel (m√°s bloques, velocidad de pelota)</li>
            </ul>

            <h3>2.3. Caracter√≠sticas de los Usuarios</h3>
            <p>
                El juego est√° dirigido a:
                <br>
                ‚óè Ni√±os y j√≥venes mayores de 10 a√±os
                <br>
                ‚óè Usuarios casuales de juegos m√≥viles
                <br>
                ‚óè Personas sin necesidad de experiencia previa en videojuegos
            </p>

            <h3>2.4. Restricciones</h3>
            <ul>
                <li>Debe funcionar correctamente en Android 10+ y iOS 14+.</li>
                <li>Resoluci√≥n m√≠nima: 720x1280 px.</li>
                <li>Lenguaje: Kotlin para Android, Swift para iOS.</li>
                <li>No debe consumir m√°s de 150MB de almacenamiento.</li>
                <li>No debe superar el uso de 20% de CPU en ejecuci√≥n continua.</li>
            </ul>

            <h3>2.5. Suposiciones y Dependencias</h3>
            <ul>
                <li>Se asume que el dispositivo tiene pantalla t√°ctil</li>
                <li>asume que hay parlantes integrados.</li>
                <li>Se usar√° Unity como motor de desarrollo.</li>
                <li>El dise√±o ser√° compatible con el modo claro y oscuro.</li>
            </ul>


            <h3>2.6. Requisitos Futuros</h3>
            <ul>
                <li>Agregar modos de juego: contrarreloj, infinito</li>
                <li>Sistema de logros y recompensas diarias</li>
                <li>Ranking local y global</li>
                <li>Personalizaci√≥n de interfaz y skins desbloqueables</li>
            </ul>


            <section class="mb-4">
                <h2 id="requisitos-especificos">3. Requisitos Espec√≠ficos</h2>
                <h3>3.1. Interfaces Externas</h3>
                <ul>
                    <li><strong>Interfaz de Usuario:</strong> Pantallas adaptativas para m√≥vil y escritorio, botones
                        t√°ctiles,
                        control por teclado.</li>
                    <li><strong>Interfaz de Hardware:</strong> Sensor t√°ctil, CPU, memoria RAM m√≠nima de 2GB.</li>
                    <li><strong>Interfaz de Software:</strong> Dependencia de motor Unity, integraci√≥n con sistema
                        operativo
                        Android/iOS.</li>
                    <li><strong>Interfaz de Comunicaci√≥n:</strong> (opcional en futuras versiones) sincronizaci√≥n de
                        logros
                        mediante red.</li>
                </ul>

                <h3>3.2. Funciones</h3>
                <ul>
                    <li>El usuario podr√° iniciar una partida desde el men√∫ principal.</li>
                    <li>El sistema detectar√° colisiones entre la pelota y los bloques, generando destrucci√≥n y sumando
                        puntaje.
                    </li>
                    <li>Se generar√°n bonificaciones aleatorias al destruir ciertos bloques.</li>
                    <li>Al terminar un nivel, se mostrar√° una pantalla con resultados y opci√≥n de avanzar.</li>
                    <li>El juego llevar√° un registro local de puntuaciones m√°ximas por usuario.</li>
                </ul>

                <h3>3.3. Requisitos de Rendimiento</h3>
                <ul>
                    <li>El juego debe mantener al menos 30 FPS en dispositivos Android 10+ e iOS 14+.</li>
                    <li>Tiempo de carga m√°ximo: 3 segundos para la pantalla inicial.</li>
                    <li>Latencia de respuesta al toque o tecla: menor a 100 ms.</li>
                </ul>

                <h3>3.4. Restricciones de Dise√±o</h3>
                <ul>
                    <li>Debe respetarse el dise√±o minimalista propuesto (no recargar la pantalla con elementos).</li>
                    <li>Las interfaces deben funcionar en orientaci√≥n vertical.</li>
                    <li>No se permitir√°n compras dentro de la app (versi√≥n inicial).</li>
                </ul>

                <h3>3.5. Atributos del Sistema</h3>
                <ul>
                    <li><strong>Fiabilidad:</strong> El sistema debe manejar excepciones sin cerrar inesperadamente.
                    </li>
                    <li><strong>Disponibilidad:</strong> La app debe estar disponible para descarga el 95% del tiempo en
                        las
                        tiendas.</li>
                    <li><strong>Seguridad:</strong> El acceso a configuraciones y datos debe ser local, sin transmitir
                        informaci√≥n externa.</li>
                    <li><strong>Mantenibilidad:</strong> El c√≥digo debe estar modularizado para facilitar futuras
                        actualizaciones.</li>
                    <li><strong>Portabilidad:</strong> Debe compilarse f√°cilmente para Android e iOS desde Unity.</li>
                </ul>

                <h3>3.6. Otros Requisitos</h3>
                <ul>
                    <li>El juego debe incluir un sistema de retroalimentaci√≥n auditiva (efectos de sonido).</li>
                    <li>Se debe incluir un tutorial b√°sico en la primera partida del usuario.</li>
                    <li>El juego debe guardar autom√°ticamente el avance del jugador.</li>
                    <li>Incluir una opci√≥n para restablecer todos los datos del juego.</li>
                </ul>
            </section>
            <section class="mb-4">
                <h2>Conclusiones y reflexiones del proceso</h2>
                <p>Durante el desarrollo de este documento, se comprendi√≥ la relevancia de levantar requisitos de forma
                    estructurada, especialmente en un proyecto aparentemente
                    simple como un videojuego arcade. El aplicar la norma IEEE 830 permiti√≥ ver c√≥mo una correcta
                    especificaci√≥n no solo aclara el alcance, sino que tambi√©n facilita la planificaci√≥n
                    y reduce errores durante el desarrollo.
                    Se identificaron tanto los aspectos funcionales del juego (como las mec√°nicas y niveles) como los no
                    funcionales (rendimiento, compatibilidad, usabilidad).
                    Cada secci√≥n fue redactada siguiendo principios de claridad, completitud y verificabilidad. Este
                    ejercicio tambi√©n resalt√≥ el valor de considerar al usuario final desde las etapas
                    iniciales y c√≥mo peque√±os detalles ‚Äîcomo el HUD, la respuesta t√°ctil o los efectos sonoros‚Äî pueden
                    impactar fuertemente la experiencia de juego.
                    En conclusi√≥n, la ingenier√≠a de requisitos no solo es aplicable a grandes sistemas corporativos,
                    sino que es fundamental en cualquier producto de software que aspire a ser funcional,
                    mantenible y agradable para el usuario final.
                </p>
            </section>
    </main>

    <section class="mb-4 text-center">
        <h2 class="text-center">Demo del Juego Arkanoid</h2>
        <canvas id="arkanoidCanvas" width="480" height="320"></canvas>
        <div class="controls-mobile">
            <button id="btnLeft">‚óÄÔ∏è</button>
            <button id="btnRight">‚ñ∂Ô∏è</button>
        </div>
    </section>

    <script>
        const canvas = document.getElementById('arkanoidCanvas');
        const ctx = canvas.getContext('2d');

        // Par√°metros
        const ballRadius = 8, paddleHeight = 10, paddleWidth = 75;
        const brickRowCount = 3, brickColumnCount = 5, brickWidth = 75;
        const brickHeight = 20, brickPadding = 10, brickOffsetTop = 30, brickOffsetLeft = 30;

        // Estado del juego
        let x = canvas.width / 2, y = canvas.height - 30, dx = 2, dy = -2;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false, leftPressed = false;
        let isGameRunning = false, isGameOver = false, gameWon = false;
        let score = 0;

        // Nombre del jugador
        let playerName = "";
        let highScore = parseInt(localStorage.getItem("arkanoidHighScore")) || 0;

        const bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }

        document.addEventListener("keydown", e => {
            if (e.key === "ArrowRight") rightPressed = true;
            else if (e.key === "ArrowLeft") leftPressed = true;
        });
        document.addEventListener("keyup", e => {
            if (e.key === "ArrowRight") rightPressed = false;
            else if (e.key === "ArrowLeft") leftPressed = false;
        });
        canvas.addEventListener("click", () => {
            if (!isGameRunning && playerName) {
                if (isGameOver || gameWon) resetGame();
                isGameRunning = true;
                draw();
            } else if (!playerName) {
                askPlayerName();
            }
        });

        function askPlayerName() {
            const name = prompt("Bienvenido a Arkanoid Revolution\nIngresa tu nombre:");
            if (name && name.trim()) {
                playerName = name.trim();
                draw();
            } else {
                playerName = "";
                drawMessage("Debes ingresar un nombre para comenzar.");
            }
        }

        function resetGame() {
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 2; dy = -2;
            paddleX = (canvas.width - paddleWidth) / 2;
            isGameOver = false;
            gameWon = false;
            score = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r].status = 1;
                }
            }
        }

        function drawHUD() {
            ctx.font = "bold 14px Arial";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "left";
            ctx.fillText(`${playerName}: ${score} / ${highScore}`, 10, 20);
        }

        function drawMessage(text) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffffff";
            ctx.font = "18px Arial";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            if (playerName) drawHUD();
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#f54291";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#42f5e9";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#ffa500";
                        ctx.fill();
                        ctx.strokeStyle = "#fff";
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy;
                            b.status = 0;
                            score += 50;
                            if (score >= 750) {
                                score = 0;
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!playerName) return askPlayerName();
            if (!isGameRunning) {
                const message = gameWon
                    ? "üéâ ¬°Ganaste! Haz clic para volver a jugar"
                    : isGameOver
                        ? "¬°Perdiste! Haz clic para reiniciar"
                        : `Hola ${playerName}, haz clic para comenzar`;
                drawMessage(message);
                return;
            }

            drawBricks();
            drawBall();
            drawPaddle();
            drawHUD();
            collisionDetection();

            const allCleared = bricks.flat().every(b => b.status === 0);
            if (allCleared) {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem("arkanoidHighScore", highScore.toString());
                }
                score = 0;
                isGameRunning = false;
                gameWon = true;
                draw();
                return;
            }


            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
            if (y + dy < ballRadius) dy = -dy;
            else if (y + dy > canvas.height - ballRadius) {
                if (x > paddleX && x < paddleX + paddleWidth) {
                    dy = -dy;
                } else {
                    isGameRunning = false;
                    isGameOver = true;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem("arkanoidHighScore", highScore.toString());
                    }
                    draw();
                    return;
                }
            }

            if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
            else if (leftPressed && paddleX > 0) paddleX -= 5;

            x += dx;
            y += dy;

            requestAnimationFrame(draw);
        }

        draw(); // mostrar pantalla inicial

        // Soporte t√°ctil
        document.getElementById("btnLeft")?.addEventListener("touchstart", () => { leftPressed = true; });
        document.getElementById("btnLeft")?.addEventListener("touchend", () => { leftPressed = false; });
        document.getElementById("btnRight")?.addEventListener("touchstart", () => { rightPressed = true; });
        document.getElementById("btnRight")?.addEventListener("touchend", () => { rightPressed = false; });
    </script>

    <footer class="main-footer">
        <p class="mb-0">&copy; 2025 Sosa, Aleja, Axel, JD. Todos los derechos reservados.</p>
    </footer>
</body>

</html>