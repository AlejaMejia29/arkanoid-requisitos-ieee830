<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Especificación de Requisitos - Arkanoid Revolution</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="CSS/style.css">
</head>

<body>
    <header class="main-header">
        <div class="container">
            <h1 class="mb-1">Especificación de Requisitos del Software (ERS)</h1>
            <h2 class="h5">Videojuego Arkanoid Revolution - Basado en IEEE 830</h2>
        </div>
    </header>

    <main class="container my-5">
        <section class="mb-4">
            <h2>Resumen del Videojuego</h2>
            <p>
                "Arkanoid Revolution" es un videojuego arcade completamente desarrollado que reinventa la experiencia
                del clásico Arkanoid, integrando gráficos modernos, jugabilidad optimizada y mecánicas complejas. El
                jugador controla una plataforma ubicada en la parte inferior de la pantalla y tiene como misión evitar
                que una esfera caiga, devolviéndola con precisión para destruir bloques fijos y móviles, algunos con
                comportamientos especiales como regeneración, movimiento lateral o cambios de estado.
            </p>
            <p>
                El juego, implementado en Unity, está disponible para dispositivos Android e iOS, incluye
                múltiples modos de juego como
                Clásico, Contrarreloj e Infinito. Cada nivel incorpora desafíos únicos: bloques móviles, físicas con
                gravedad variable, enemigos que interfieren con el rebote, y obstáculos que requieren estrategias
                distintas. El sistema recompensa al jugador con bonificaciones como pelotas múltiples, rayos láser,
                escudos, velocidad reducida y duplicadores de puntaje.
            </p>
            <p>
                El diseño de "Arkanoid Revolution" ofrece una interfaz minimalista adaptada exclusivamente a pantallas
                táctiles. Se han implementado retroalimentaciones auditiva, visual y respuesta táctil, junto con un
                sistema de logros, desbloqueo de contenido oculto y un sistema de puntuación que incentiva la mejora
                constante del jugador. Todo esto contribuye a una experiencia inmersiva, exigente y altamente rejugable.

            </p>
        </section>
        <section class="mb-4">
            <h2>Índice</h2>
            <ul>
                <li><strong>1. Introducción</strong>
                    <ul>
                        <li>1.1. Propósito</li>
                        <li>1.2. Ámbito del Sistema</li>
                        <li>1.3. Definiciones, Acrónimos y Abreviaturas</li>
                        <li>1.4. Referencias</li>
                        <li>1.5. Visión General del Documento</li>
                    </ul>
                </li>
                <li><strong>2. Descripción General</strong>
                    <ul>
                        <li>2.1. Perspectiva del Producto</li>
                        <li>2.2. Funciones del Producto</li>
                        <li>2.3. Características de los Usuarios</li>
                        <li>2.4. Restricciones</li>
                        <li>2.5. Suposiciones y Dependencias</li>
                        <li>2.6. Requisitos Futuros</li>
                    </ul>
                </li>
                <li><strong>3. Requisitos Específicos</strong>
                    <ul>
                        <li>3.1. Interfaces Externas</li>
                        <li>3.2. Funciones</li>
                        <li>3.3. Requisitos de Rendimiento</li>
                        <li>3.4. Restricciones de Diseño</li>
                        <li>3.5. Atributos del Sistema</li>
                        <li>3.6. Otros Requisitos</li>
                    </ul>
                </li>
                <li><strong>4. Apéndices</strong></li>
            </ul>
        </section>
        <section class="mb-4">
            <h2>1. Introducción</h2>

            <h3>1.1. Propósito</h3>
            <p>
                Este documento tiene como objetivo describir detalladamente los requerimientos funcionales y no
                funcionales del videojuego ya implementado y en funcionamiento “Arkanoid Revolution”, siguiendo la norma
                IEEE 830. Está dirigido a profesionales involucrados en el mantenimiento, escalabilidad y mejora
                continua del sistema, así como a desarrolladores interesados en futuras extensiones del producto.
            </p>

            <h3>1.2. Ámbito del Sistema</h3>
            <p>
                El sistema consiste en un videojuego arcade completo que se ejecuta tanto en dispositivos Android como
                iOS. El usuario controla una plataforma móvil para mantener en juego una esfera, destruir
                bloques, obtener potenciadores, desbloquear logros y avanzar a través de múltiples niveles. Se ha
                priorizado la experiencia offline, por lo que no depende de conexión constante ni de funcionalidades
                multijugador en esta versión estable.
            </p>

            <h3>1.3. Definiciones, Acrónimos y Abreviaturas</h3>
            <ul>
                <li><strong>UI (User Interface / Interfaz de Usuario): </strong> Todo lo visual con lo que el jugador
                    interactúa (botones, menús, pantallas).</li>
                <li><strong>UX (User Experience / Experiencia del Usuario): </strong> Cómo se siente jugar el juego: si
                    es cómodo, fluido y entendible.</li>
                <li><strong>FPS (Frames Per Second / Cuadros por segundo): </strong> Cuántas imágenes por segundo se
                    muestran; afecta la fluidez visual.</li>
                <li><strong>HUD (Head-Up Display): </strong> Información sobre el juego mostrada en pantalla sin
                    interrumpir la acción (ej: puntaje, vidas, nivel actual).</li>
                <li><strong>API (Application Programming Interface): </strong>Conjunto de funciones que permiten al
                    juego comunicarse con otras partes del sistema (como sonidos o sensores).</li>


            </ul>

            <h3>1.4. Referencias</h3>
            <ul>
                <li><strong>IEEE Std 830-1998: </strong>Norma internacional que establece cómo documentar correctamente
                    los requerimientos de un software.</li>
                <li><strong>Documentación oficial del motor Unity: </strong>Manual oficial de la herramienta usada para
                    desarrollar el juego; contiene instrucciones sobre físicas, animaciones, interfaz, rendimiento, etc.
                </li>
                <li><strong>Guías HIG (Apple) y Material Design (Android): </strong>Normas visuales y de usabilidad
                    recomendadas por cada sistema operativo para asegurar una experiencia consistente en móviles.</li>
                <li><strong>Manual técnico del proyecto “Arkanoid Revolution”: </strong>Documento interno del equipo
                    donde se detalla la estructura del código, configuración del juego, decisiones de diseño y
                    dependencias utilizadas.</li>
            </ul>

            <h3>1.5. Visión General del Documento</h3>
            <p>
                Este documento está estructurado para reflejar claramente el producto ya desarrollado. La sección 2
                presenta una visión general del sistema, sus usuarios y entorno. La sección 3 detalla los requerimientos
                implementados, funcionales y no funcionales, junto a restricciones de diseño y rendimiento. Finalmente,
                la sección 4 recoge reflexiones sobre el proceso de ingeniería y documentación del sistema, resaltando
                la utilidad del enfoque estructurado que propone el estándar IEEE 830.
            </p>
        </section>
        <section class="mb-4">
            <h2>2. Descripción General</h2>

            <h3>2.1. Perspectiva del Producto</h3>
            <p>
                El producto es una aplicación móvil completamente funcional para Android e iOS. No requiere conexión
                permanente a internet, ya que todo el contenido está disponible localmente. Su arquitectura sigue el
                patrón Modelo-Vista-Controlador (MVC), facilitando el mantenimiento y escalabilidad.
                <br>
                Ejemplo: un usuario descarga Arkanoid Revolution desde la tienda, lo abre sin registrarse, selecciona un
                modo de juego y comienza a jugar sin necesidad de conexión a internet.</br>

            </p>

            <h3>2.2. Funciones del Producto</h3>
            <ul>
                <li>Iniciar partida desde menú principal</li>
                <li>Controlar la plataforma deslizando el dedo horizontalmente</li>
                <li>Detectar colisiones entre la pelota y los bloques</li>
                <li>Romper bloques y actualizar el puntaje</li>
                <li>Aumentar dificultad con cada nivel (más bloques, velocidad de pelota)</li>
                <li>Aumentar la dificultad de manera progresiva (bloques más rápidos, enemigos móviles, gravedad
                    variable).
                <li>Obtener bonificaciones como rayos láser, esferas múltiples, escudos o ralentización del tiempo.</li>
            </ul>

            <h3>2.3. Características de los Usuarios</h3>
            El juego está dirigido a:
            <ul>
                <li>Niños y jóvenes mayores de 10 años que buscan desafíos arcade. </li>
                <li>Usuarios casuales de juegos móviles.</li>
                <li>Personas sin experiencia previa en videojuegos, gracias a su tutorial inicial interactivo.</li>
                <li>Jugadores que disfrutan de sistemas de superación personal y desbloqueo progresivo.</li>
            </ul>

            <h3>2.4. Restricciones</h3>
            <ul>
                <li>Debe funcionar correctamente en Android 10+ y iOS 14+.</li>
                <li>Resolución mínima: 720x1280 px.</li>
                <li>Lenguaje: Kotlin para Android, Swift para iOS.</li>
                <li>Tamaño de instalación inferior a 150MB.</li>
                <li>Uso de CPU optimizado para no superar el 20% durante sesiones normales.</li>
            </ul>

            <h3>2.5. Suposiciones y Dependencias</h3>
            <ul>
                <li>Se asume que el dispositivo posee pantalla táctil y parlantes.</li>
                <li>Unity fue utilizado como motor gráfico y de física del juego.</li>
                <li>La interfaz se adapta tanto al modo claro como oscuro del sistema.</li>
                <li>No se requiere conexión a internet durante el uso.</li>
            </ul>


            <h3>2.6. Requisitos Futuros</h3>
            <ul>
                <li>Agregar modos de juego adicionales (Supervivencia, Desafío diario).</li>
                <li>Sistema de logros y recompensas diarias</li>
                <li>Editor de niveles para crear y compartir desafíos personalizados.</li>
                <li>Nuevas skins y temas visuales desbloqueables según logros.</li>
            </ul>


            <section class="mb-4">
                <h2 id="requisitos-especificos">3. Requisitos Específicos</h2>
                <h3>3.1. Interfaces Externas</h3>
                <ul>
                    <li><strong>Interfaz de Usuario:</strong> Pantallas adaptadas a móviles, botones táctiles grandes,
                        íconos intuitivos.</li>
                    <li><strong>Interfaz de Hardware:</strong> Sensor táctil, acelerómetro, mínimo 2GB de RAM.</li>
                    <li><strong>Interfaz de Software:</strong> Dependencia del motor Unity y sistema operativo móvil.
                    </li>
                    <li><strong>Interfaz de Comunicación:</strong> No se utiliza en la versión actual; futuras versiones
                        podrían sincronizar logros en la nube.</li>
                </ul>

                <h3>3.2. Funciones</h3>
                <ul>
                    <li>El usuario puede iniciar partidas sin necesidad de iniciar sesión.</li>
                    <li>Las colisiones generan efectos visuales y de sonido.</li>
                    <li>Algunos bloques necesitan varios golpes para romperse o, al hacerlo, también destruyen los
                        bloques cercanos.
                    </li>
                    <li>Al completar un nivel, se muestra un resumen con puntaje, tiempo y rendimiento.</li>
                    <li>El progreso y estadísticas del usuario se guardan en el dispositivo.</li>
                </ul>

                <h3>3.3. Requisitos de Rendimiento</h3>
                <ul>
                    <li>El juego debe mantener al menos 30 FPS en dispositivos Android 10+ e iOS 14+.</li>
                    <li>Tiempo de carga inicial máximo: 3 segundos.</li>
                    <li>Latencia de respuesta al toque: menor a 100 ms.</li>
                    <li>Transiciones suaves entre pantallas y niveles, sin bloqueos. </li>
                </ul>

                <h3>3.4. Restricciones de Diseño</h3>
                <ul>
                    <li>Diseño minimalista con prioridad en la claridad visual.</li>
                    <li>El juego funciona solo en orientación vertical.</li>
                    <li>No hay compras dentro de la app en esta versión (modelo gratuito completo).</li>
                </ul>

                <h3>3.5. Atributos del Sistema</h3>
                <ul>
                    <li><strong>Fiabilidad:</strong> Manejo de errores y cierres controlados sin pérdida de datos.
                    </li>
                    <li><strong>Disponibilidad:</strong> Publicado en tiendas oficiales con tasa de disponibilidad mayor
                        al 95%.</li>
                    <li><strong>Seguridad:</strong> El almacenamiento local de datos evita filtraciones externas.</li>
                    <li><strong>Mantenibilidad:</strong> El código del juego está organizado por partes para que sea
                        fácil de actualizar, y se lleva un control de los cambios en un repositorio.</li>
                    <li><strong>Portabilidad:</strong> Compilación adaptada para Android e iOS desde el mismo proyecto
                        Unity.</li>
                </ul>

                <h3>3.6. Otros Requisitos</h3>
                <ul>
                    <li>Efectos de sonido personalizables y control de volumen interno.</li>
                    <li>Tutorial introductorio automático en la primera ejecución.</li>
                    <li>El juego debe guardar automáticamente el avance del jugador.</li>
                    <li>Sistema para restablecer progreso y configuraciones desde el menú.</li>
                    <li>Opciones de accesibilidad para contraste y tamaño de texto.</li>
                </ul>
            </section>
            <section class="mb-4">
                <h2>Conclusiones y reflexiones del proceso</h2>
                <p>Durante la elaboración de este documento, se reafirmó la importancia de levantar requisitos de forma
                    ordenada y detallada, incluso en proyectos que a primera vista pueden parecer simples, como un
                    videojuego arcade. Documentar “Arkanoid Revolution” bajo el estándar IEEE 830 permitió estructurar
                    cada aspecto del juego de manera clara, desde su funcionamiento general hasta los requisitos
                    técnicos más específicos.
                </p>
                <p>

                    Gracias a este enfoque, fue posible describir un producto que ya se encuentra completamente
                    desarrollado, funcional y disponible para plataformas móviles, con mecánicas variadas, niveles
                    progresivos, modos de juego distintos y una experiencia visual y táctil cuidadosamente diseñada.
                    Cada sección del documento mantiene coherencia con el estado real del proyecto, destacando tanto las
                    características técnicas como la perspectiva del jugador final.</p>

                <p>
                    Además, este ejercicio permitió reflexionar sobre cómo elementos como la jugabilidad, la
                    accesibilidad, la respuesta táctil o la organización del código influyen directamente en la calidad
                    del software. Concluir este proceso demuestra que la ingeniería de requisitos no es exclusiva de
                    proyectos empresariales complejos, sino una herramienta clave para desarrollar productos completos,
                    eficientes y centrados en el usuario.
                </p>
            </section>
    </main>

    <section class="mb-4 text-center">
        <h2 class="text-center">Demo del Juego Arkanoid Revolution</h2>
        <canvas id="arkanoidCanvas" width="480" height="320"></canvas>
        <div class="controls-mobile">
            <button id="btnLeft">◀️</button>
            <button id="btnRight">▶️</button>
        </div>
    </section>

    <script>
        const canvas = document.getElementById('arkanoidCanvas');
        const ctx = canvas.getContext('2d');

        // Parámetros
        const ballRadius = 8, paddleHeight = 10, paddleWidth = 75;
        const brickRowCount = 3, brickColumnCount = 5, brickWidth = 75;
        const brickHeight = 20, brickPadding = 10, brickOffsetTop = 30, brickOffsetLeft = 30;

        // Estado del juego
        let x = canvas.width / 2, y = canvas.height - 30, dx = 2, dy = -2;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false, leftPressed = false;
        let isGameRunning = false, isGameOver = false, gameWon = false;
        let score = 0;

        // Nombre del jugador
        let playerName = "";
        let highScore = parseInt(localStorage.getItem("arkanoidHighScore")) || 0;

        const bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }

        document.addEventListener("keydown", e => {
            if (e.key === "ArrowRight") rightPressed = true;
            else if (e.key === "ArrowLeft") leftPressed = true;
        });
        document.addEventListener("keyup", e => {
            if (e.key === "ArrowRight") rightPressed = false;
            else if (e.key === "ArrowLeft") leftPressed = false;
        });
        canvas.addEventListener("click", () => {
            if (!isGameRunning && playerName) {
                if (isGameOver || gameWon) resetGame();
                isGameRunning = true;
                draw();
            } else if (!playerName) {
                askPlayerName();
            }
        });

        function askPlayerName() {
            const name = prompt("Bienvenido a Arkanoid Revolution\nIngresa tu nombre:");
            if (name && name.trim()) {
                playerName = name.trim();
                draw();
            } else {
                playerName = "";
                drawMessage("Debes ingresar un nombre para comenzar.");
            }
        }

        function resetGame() {
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 2; dy = -2;
            paddleX = (canvas.width - paddleWidth) / 2;
            isGameOver = false;
            gameWon = false;
            score = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r].status = 1;
                }
            }
        }

        function drawHUD() {
            ctx.font = "bold 14px Arial";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "left";
            ctx.fillText(`${playerName}: ${score} / ${highScore}`, 10, 20);
        }

        function drawMessage(text) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffffff";
            ctx.font = "18px Arial";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            if (playerName) drawHUD();
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#f54291";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#42f5e9";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#ffa500";
                        ctx.fill();
                        ctx.strokeStyle = "#fff";
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy;
                            b.status = 0;
                            score += 50;
                            if (score >= 750) {
                                score = 0;
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!playerName) return askPlayerName();
            if (!isGameRunning) {
                const message = gameWon
                    ? "🎉 ¡Ganaste! Haz clic para volver a jugar"
                    : isGameOver
                        ? "¡Perdiste! Haz clic para reiniciar"
                        : `Hola ${playerName}, haz clic para comenzar`;
                drawMessage(message);
                return;
            }

            drawBricks();
            drawBall();
            drawPaddle();
            drawHUD();
            collisionDetection();

            const allCleared = bricks.flat().every(b => b.status === 0);
            if (allCleared) {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem("arkanoidHighScore", highScore.toString());
                }
                score = 0;
                isGameRunning = false;
                gameWon = true;
                draw();
                return;
            }


            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
            if (y + dy < ballRadius) dy = -dy;
            else if (y + dy > canvas.height - ballRadius) {
                if (x > paddleX && x < paddleX + paddleWidth) {
                    dy = -dy;
                } else {
                    isGameRunning = false;
                    isGameOver = true;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem("arkanoidHighScore", highScore.toString());
                    }
                    draw();
                    return;
                }
            }

            if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
            else if (leftPressed && paddleX > 0) paddleX -= 5;

            x += dx;
            y += dy;

            requestAnimationFrame(draw);
        }

        draw(); // mostrar pantalla inicial

        // Soporte táctil
        document.getElementById("btnLeft")?.addEventListener("touchstart", () => { leftPressed = true; });
        document.getElementById("btnLeft")?.addEventListener("touchend", () => { leftPressed = false; });
        document.getElementById("btnRight")?.addEventListener("touchstart", () => { rightPressed = true; });
        document.getElementById("btnRight")?.addEventListener("touchend", () => { rightPressed = false; });
    </script>

    <footer class="main-footer">
        <p class="mb-0">&copy; 2025 Sosa, Aleja, Axel, JD. Todos los derechos reservados.</p>
    </footer>
</body>

</html>