<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Especificación de Requisitos - Arkanoid Revolution</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="CSS/style.css">
</head>

<body>
    <header class="main-header">
        <div class="container">
            <h1 class="mb-1">Especificación de Requisitos del Software (ERS)</h1>
            <h2 class="h5">Videojuego Arkanoid Revolution - Basado en IEEE 830</h2>
        </div>
    </header>

    <main class="container my-5">
        <section class="mb-4">
            <h2>Resumen del Videojuego</h2>
            <p>
                "Arkanoid Revolution" es un videojuego arcade que retoma la esencia del clásico Arkanoid, mejorándola
                con una experiencia gráfica moderna, niveles con mayor dinamismo, mecánicas variadas y una curva de
                dificultad progresiva. El jugador asume el control de una plataforma ubicada en la parte inferior de la
                pantalla, cuya misión es evitar que una pelota caiga, devolviéndola con precisión para destruir una
                serie de bloques que se ubican en la parte superior.
            </p>
            <p>
                A medida que avanza, el jugador desbloqueará bonificaciones (como multiplicadores, rayos láser, pelotas
                múltiples, entre otros) y se enfrentará a nuevos retos como bloques móviles, enemigos que interfieren el
                rebote, y niveles con gravedades modificadas.
            </p>
            <p>
                El juego se divide en distintos niveles con objetivos y condiciones específicas: desde eliminar todos
                los bloques en un tiempo límite, hasta proteger ciertas estructuras o alcanzar una puntuación mínima
                para avanzar. La interfaz es minimalista y amigable, y el sistema de retroalimentación (sonido,
                vibración, animaciones) está diseñado para mantener al jugador inmerso. Con soporte para dispositivos
                táctiles y de escritorio, "Arkanoid Revolution" busca ser un título accesible para todo tipo de jugador,
                promoviendo la rejugabilidad mediante tablas de puntajes, logros desbloqueables y contenido oculto que
                se desbloquea con el progreso.
            </p>
        </section>
        <section class="mb-4">
            <h2>Índice</h2>
            <ul>
                <li><strong>1. Introducción</strong>
                    <ul>
                        <li>1.1. Propósito</li>
                        <li>1.2. Ámbito del Sistema</li>
                        <li>1.3. Definiciones, Acrónimos y Abreviaturas</li>
                        <li>1.4. Referencias</li>
                        <li>1.5. Visión General del Documento</li>
                    </ul>
                </li>
                <li><strong>2. Descripción General</strong>
                    <ul>
                        <li>2.1. Perspectiva del Producto</li>
                        <li>2.2. Funciones del Producto</li>
                        <li>2.3. Características de los Usuarios</li>
                        <li>2.4. Restricciones</li>
                        <li>2.5. Suposiciones y Dependencias</li>
                        <li>2.6. Requisitos Futuros</li>
                    </ul>
                </li>
                <li><strong>3. Requisitos Específicos</strong>
                    <ul>
                        <li>3.1. Interfaces Externas</li>
                        <li>3.2. Funciones</li>
                        <li>3.3. Requisitos de Rendimiento</li>
                        <li>3.4. Restricciones de Diseño</li>
                        <li>3.5. Atributos del Sistema</li>
                        <li>3.6. Otros Requisitos</li>
                    </ul>
                </li>
            </ul>
        </section>
        <section class="mb-4">
            <h2>1. Introducción</h2>

            <h3>1.1. Propósito</h3>
            <p>
                El presente documento tiene como propósito especificar de manera detallada los requerimientos
                funcionales y no funcionales del videojuego "Arkanoid Revolution", bajo el estándar IEEE 830. Está
                dirigido a desarrolladores, testers, diseñadores y otros interesados en el proceso de desarrollo del
                software.
            </p>

            <h3>1.2. Ámbito del Sistema</h3>
            <p>
                El sistema a desarrollar es un videojuego arcade tipo Arkanoid para navegadores y dispositivos móviles.
                El juego permitirá al jugador interactuar mediante teclado o pantalla táctil, rebotar la pelota,
                destruir bloques, obtener mejoras, superar niveles y registrar puntajes. No incluirá opciones
                multijugador ni integración en la nube en esta versión.
            </p>

            <h3>1.3. Definiciones, Acrónimos y Abreviaturas</h3>
            <ul>
                <li><strong>UI:</strong> Interfaz de Usuario</li>
                <li><strong>FPS:</strong> Frames por Segundo</li>
                <li><strong>HTML5:</strong> Lenguaje de marcado usado para crear la estructura del juego</li>
                <li><strong>API:</strong> Interfaz de Programación de Aplicaciones</li>
                <li><strong>UX:</strong> Experiencia del Usuario</li>
            </ul>

            <h3>1.4. Referencias</h3>
            <ul>
                <li>IEEE Std 830-1998</li>
                <li>Documentación de Phaser.js (motor de juegos)</li>
            </ul>

            <h3>1.5. Visión General del Documento</h3>
            <p>
                Este documento sigue la estructura del estándar IEEE 830 y se divide en tres partes: descripción general
                del sistema, requerimientos específicos (funcionales y no funcionales).
            </p>
        </section>
        <section class="mb-4">
            <h2>2. Descripción General</h2>

            <h3>2.1. Perspectiva del Producto</h3>
            <p>
                El producto es independiente y autónomo, instalable como aplicación móvil. No requiere conexión
                permanente a internet. Su arquitectura está basada en MVC, y se ejecuta sobre el sistema operativo
                Android/iOS.
                <br>Ejemplo: un usuario descarga Arkanoid en su celular, lo ejecuta, elige un nivel inicial y comienza a
                jugar sin requerir cuenta o conexión.

            </p>

            <h3>2.2. Funciones del Producto</h3>
            <ul>
                <li>Iniciar partida desde menú principal</li>
                <li>Controlar la plataforma deslizando el dedo horizontalmente</li>
                <li>Detectar colisiones entre la pelota y los bloques</li>
                <li>Romper bloques y actualizar el puntaje</li>
                <li>Aumentar dificultad con cada nivel (más bloques, velocidad de pelota)</li>
            </ul>

            <h3>2.3. Características de los Usuarios</h3>
            <p>
                El juego está dirigido a:
                <br>
                ● Niños y jóvenes mayores de 10 años
                <br>
                ● Usuarios casuales de juegos móviles
                <br>
                ● Personas sin necesidad de experiencia previa en videojuegos
            </p>

            <h3>2.4. Restricciones</h3>
            <ul>
                <li>Debe funcionar correctamente en Android 10+ y iOS 14+.</li>
                <li>Resolución mínima: 720x1280 px.</li>
                <li>Lenguaje: Kotlin para Android, Swift para iOS.</li>
                <li>No debe consumir más de 150MB de almacenamiento.</li>
                <li>No debe superar el uso de 20% de CPU en ejecución continua.</li>
            </ul>

            <h3>2.5. Suposiciones y Dependencias</h3>
            <ul>
                <li>Se asume que el dispositivo tiene pantalla táctil</li>
                <li>asume que hay parlantes integrados.</li>
                <li>Se usará Unity como motor de desarrollo.</li>
                <li>El diseño será compatible con el modo claro y oscuro.</li>
            </ul>


            <h3>2.6. Requisitos Futuros</h3>
            <ul>
                <li>Agregar modos de juego: contrarreloj, infinito</li>
                <li>Sistema de logros y recompensas diarias</li>
                <li>Ranking local y global</li>
                <li>Personalización de interfaz y skins desbloqueables</li>
            </ul>


            <section class="mb-4">
                <h2 id="requisitos-especificos">3. Requisitos Específicos</h2>
                <h3>3.1. Interfaces Externas</h3>
                <ul>
                    <li><strong>Interfaz de Usuario:</strong> Pantallas adaptativas para móvil y escritorio, botones
                        táctiles,
                        control por teclado.</li>
                    <li><strong>Interfaz de Hardware:</strong> Sensor táctil, CPU, memoria RAM mínima de 2GB.</li>
                    <li><strong>Interfaz de Software:</strong> Dependencia de motor Unity, integración con sistema
                        operativo
                        Android/iOS.</li>
                    <li><strong>Interfaz de Comunicación:</strong> (opcional en futuras versiones) sincronización de
                        logros
                        mediante red.</li>
                </ul>

                <h3>3.2. Funciones</h3>
                <ul>
                    <li>El usuario podrá iniciar una partida desde el menú principal.</li>
                    <li>El sistema detectará colisiones entre la pelota y los bloques, generando destrucción y sumando
                        puntaje.
                    </li>
                    <li>Se generarán bonificaciones aleatorias al destruir ciertos bloques.</li>
                    <li>Al terminar un nivel, se mostrará una pantalla con resultados y opción de avanzar.</li>
                    <li>El juego llevará un registro local de puntuaciones máximas por usuario.</li>
                </ul>

                <h3>3.3. Requisitos de Rendimiento</h3>
                <ul>
                    <li>El juego debe mantener al menos 30 FPS en dispositivos Android 10+ e iOS 14+.</li>
                    <li>Tiempo de carga máximo: 3 segundos para la pantalla inicial.</li>
                    <li>Latencia de respuesta al toque o tecla: menor a 100 ms.</li>
                </ul>

                <h3>3.4. Restricciones de Diseño</h3>
                <ul>
                    <li>Debe respetarse el diseño minimalista propuesto (no recargar la pantalla con elementos).</li>
                    <li>Las interfaces deben funcionar en orientación vertical.</li>
                    <li>No se permitirán compras dentro de la app (versión inicial).</li>
                </ul>

                <h3>3.5. Atributos del Sistema</h3>
                <ul>
                    <li><strong>Fiabilidad:</strong> El sistema debe manejar excepciones sin cerrar inesperadamente.
                    </li>
                    <li><strong>Disponibilidad:</strong> La app debe estar disponible para descarga el 95% del tiempo en
                        las
                        tiendas.</li>
                    <li><strong>Seguridad:</strong> El acceso a configuraciones y datos debe ser local, sin transmitir
                        información externa.</li>
                    <li><strong>Mantenibilidad:</strong> El código debe estar modularizado para facilitar futuras
                        actualizaciones.</li>
                    <li><strong>Portabilidad:</strong> Debe compilarse fácilmente para Android e iOS desde Unity.</li>
                </ul>

                <h3>3.6. Otros Requisitos</h3>
                <ul>
                    <li>El juego debe incluir un sistema de retroalimentación auditiva (efectos de sonido).</li>
                    <li>Se debe incluir un tutorial básico en la primera partida del usuario.</li>
                    <li>El juego debe guardar automáticamente el avance del jugador.</li>
                    <li>Incluir una opción para restablecer todos los datos del juego.</li>
                </ul>
            </section>
            <section class="mb-4">
                <h2>Conclusiones y reflexiones del proceso</h2>
                <p>Durante el desarrollo de este documento, se comprendió la relevancia de levantar requisitos de forma
                    estructurada, especialmente en un proyecto aparentemente
                    simple como un videojuego arcade. El aplicar la norma IEEE 830 permitió ver cómo una correcta
                    especificación no solo aclara el alcance, sino que también facilita la planificación
                    y reduce errores durante el desarrollo.
                    Se identificaron tanto los aspectos funcionales del juego (como las mecánicas y niveles) como los no
                    funcionales (rendimiento, compatibilidad, usabilidad).
                    Cada sección fue redactada siguiendo principios de claridad, completitud y verificabilidad. Este
                    ejercicio también resaltó el valor de considerar al usuario final desde las etapas
                    iniciales y cómo pequeños detalles —como el HUD, la respuesta táctil o los efectos sonoros— pueden
                    impactar fuertemente la experiencia de juego.
                    En conclusión, la ingeniería de requisitos no solo es aplicable a grandes sistemas corporativos,
                    sino que es fundamental en cualquier producto de software que aspire a ser funcional,
                    mantenible y agradable para el usuario final.
                </p>
            </section>
    </main>

    <section class="mb-4 text-center">
        <h2 class="text-center">Demo del Juego Arkanoid</h2>
        <canvas id="arkanoidCanvas" width="480" height="320"></canvas>
        <div class="controls-mobile">
            <button id="btnLeft">◀️</button>
            <button id="btnRight">▶️</button>
        </div>
    </section>

    <script>
        const canvas = document.getElementById('arkanoidCanvas');
        const ctx = canvas.getContext('2d');

        // Parámetros
        const ballRadius = 8, paddleHeight = 10, paddleWidth = 75;
        const brickRowCount = 3, brickColumnCount = 5, brickWidth = 75;
        const brickHeight = 20, brickPadding = 10, brickOffsetTop = 30, brickOffsetLeft = 30;

        // Estado del juego
        let x = canvas.width / 2, y = canvas.height - 30, dx = 2, dy = -2;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false, leftPressed = false;
        let isGameRunning = false, isGameOver = false, gameWon = false;
        let score = 0;

        // Nombre del jugador
        let playerName = "";
        let highScore = parseInt(localStorage.getItem("arkanoidHighScore")) || 0;

        const bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }

        document.addEventListener("keydown", e => {
            if (e.key === "ArrowRight") rightPressed = true;
            else if (e.key === "ArrowLeft") leftPressed = true;
        });
        document.addEventListener("keyup", e => {
            if (e.key === "ArrowRight") rightPressed = false;
            else if (e.key === "ArrowLeft") leftPressed = false;
        });
        canvas.addEventListener("click", () => {
            if (!isGameRunning && playerName) {
                if (isGameOver || gameWon) resetGame();
                isGameRunning = true;
                draw();
            } else if (!playerName) {
                askPlayerName();
            }
        });

        function askPlayerName() {
            const name = prompt("Bienvenido a Arkanoid Revolution\nIngresa tu nombre:");
            if (name && name.trim()) {
                playerName = name.trim();
                draw();
            } else {
                playerName = "";
                drawMessage("Debes ingresar un nombre para comenzar.");
            }
        }

        function resetGame() {
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 2; dy = -2;
            paddleX = (canvas.width - paddleWidth) / 2;
            isGameOver = false;
            gameWon = false;
            score = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r].status = 1;
                }
            }
        }

        function drawHUD() {
            ctx.font = "bold 14px Arial";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "left";
            ctx.fillText(`${playerName}: ${score} / ${highScore}`, 10, 20);
        }

        function drawMessage(text) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ffffff";
            ctx.font = "18px Arial";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            if (playerName) drawHUD();
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#f54291";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#42f5e9";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#ffa500";
                        ctx.fill();
                        ctx.strokeStyle = "#fff";
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy;
                            b.status = 0;
                            score += 50;
                            if (score >= 750) {
                                score = 0;
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!playerName) return askPlayerName();
            if (!isGameRunning) {
                const message = gameWon
                    ? "🎉 ¡Ganaste! Haz clic para volver a jugar"
                    : isGameOver
                        ? "¡Perdiste! Haz clic para reiniciar"
                        : `Hola ${playerName}, haz clic para comenzar`;
                drawMessage(message);
                return;
            }

            drawBricks();
            drawBall();
            drawPaddle();
            drawHUD();
            collisionDetection();

            const allCleared = bricks.flat().every(b => b.status === 0);
            if (allCleared) {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem("arkanoidHighScore", highScore.toString());
                }
                score = 0;
                isGameRunning = false;
                gameWon = true;
                draw();
                return;
            }


            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
            if (y + dy < ballRadius) dy = -dy;
            else if (y + dy > canvas.height - ballRadius) {
                if (x > paddleX && x < paddleX + paddleWidth) {
                    dy = -dy;
                } else {
                    isGameRunning = false;
                    isGameOver = true;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem("arkanoidHighScore", highScore.toString());
                    }
                    draw();
                    return;
                }
            }

            if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
            else if (leftPressed && paddleX > 0) paddleX -= 5;

            x += dx;
            y += dy;

            requestAnimationFrame(draw);
        }

        draw(); // mostrar pantalla inicial

        // Soporte táctil
        document.getElementById("btnLeft")?.addEventListener("touchstart", () => { leftPressed = true; });
        document.getElementById("btnLeft")?.addEventListener("touchend", () => { leftPressed = false; });
        document.getElementById("btnRight")?.addEventListener("touchstart", () => { rightPressed = true; });
        document.getElementById("btnRight")?.addEventListener("touchend", () => { rightPressed = false; });
    </script>

    <footer class="main-footer">
        <p class="mb-0">&copy; 2025 Sosa, Aleja, Axel, JD. Todos los derechos reservados.</p>
    </footer>
</body>

</html>